### 함수

#### 분해 - Decomposition

- 기능을 분해하고 재사용 가능하게 만들고

#### 추상화 - Abstraction

- 복잡한 내용을 모르더라도 사용할 수 있도록(스마트폰)
- 재사용성과 가독성, 생산성
- 사실 내부 구조를 변경할게 아니라면 몰라도 무방
    - 그것이 함수의 장점이자 프로그래밍의 매력
    - 스마트폰의 원리를 잘 몰라도 우리는 잘 사용할 수 있음

#### 함수의 종류 - 크게 3가지

- 내장 함수
    - 파이썬에 기본적으로 포함된 함수
- 외장함수
    - import문을 통해 사용하며, 외부 라이브러리에서 제공하는 함수
- 사용자 정의 함수
    - 직접 사용자가 만드는 함수
    

#### 함수 기본 구조

- 선언과 호출(define & call)
- 입력(input)
- 문서화(Docstring)
- 범위(Scope)
- 결과값(Output)

#### 선언과 호출

- 함수의 선언은 `def 키워드`를 활용함
- 들여쓰기를 통해 `Function body`(실행될 코드 블록)를 작성함
    - Docstring은 함수 body 앞에 선택적으로 작성 가능
        - 작성 시에는 반드시 첫 번째 문장에 문자열 “””
- 함수는 `parameter`를 넘겨줄 수 있음
- 함수는 동작 후에 `return`을 통해 결과값을 전달함

> print를 사용하면 호출 될 때마다 값이 출력됨 ( 주로 테스트를 위해)데이터 처리를 위해서는 return 사용

#### 두 개 이상의 값 반환
- 튜플을 활용하여 두 개 이상의 값 반환
- 함수 반환 정리

#### Parameter와 Argument
##### Argument

- 함수 호출 시 함수의 parameter를 통해 전달되는 값
- Argument는 소괄호 안에 할당 func_name(argument)
    - 필수 Argument : 반드시 전달되어야 하는 argument
    - 선택 Argument : 값을 전달하지 않아도 되는 경우는 기본값이 전달

##### Positional Arguments
##### Default Arguments Values

#### 가변 인자(*args)

##### 패킹/ 언패킹

- 가변 인자를 이해하기 위해서는 패킹, 언패킹을 이해해야 함
- 패킹 : 여러 개의 데이터를 묶어서 변수에 할당하는것
- 언패킹 : 시퀀스 속의 요소들을 여러 개의 변수에 나누어 할당하는 것
    - 언패킹시 변수의 개수와 할당하고자 하는 요소의 갯수가 동일해야함
    - 언패킹시 왼족의 변수에 asterisk(*)르 붙이면, 할당하고 남은 요소를 리스트에 담을 수 있음

##### Asterisk(*)와 가변 인자

- *는 스퀸스 언패킹 연산자라고도 불리며, 말 그대로 시퀀스를 풀어 헤치는 연산자
    - 주로 튜플이나 리스트를 언패킹하는데 사용
    - *를 활용하여 가변 인자를 만들 수 있음

##### 가변 키워드 인자(**kwargs)

- 몇 개의 키워드 인자를 받을지 모르는 함수를 정의할 때 유용
- **kwargs는 딕셔너리로 묶여 처리되며, parameter에 **를 붙여 표현
- 반드시 받아야하는 키워드 인자와, 추가적인 키워드 인자를 구분해서 사용할 수 있음

> 가변인자(*args) 가변키워드 인자(**kwargs) 혼용 가능!

#### 파이썬의 범위 (Scope)

- 함수는 코드 내부에 `local scope`를 생성하며, 그 외의 공간인 `global scope`로 구분
- scope
    - global scope : 코드 어디에서든 참조할 수 있는 공간
    - local scope : 함수가 만든 scope. 함수 내부에서만 참조 가능
- variable
    - global variable : global scope 에 정의된 변수
    - local variable : local scope 에 정의된 변수

#### 변수 수명주기 (lifecycle)

- 변수는 각자의 수명주기(lifecycle)가 존재
    - built-in scope
        - 파이썬이 실행된 이후부터 영원히 유지
    - global scope
        - 모듈이 호출된 시점 이후 혹은 인터프리터가 끝날 때까지 유지
    - local scope
        - 함수가 호출될 때 생성되고, 함수가 종료될 때까지 유지

#### 이름 검색 규칙(Name Resolution)

- 파이썬에서 사용되는 이름(식별자)들은 이름공간(namespace)에 저장
- 아래와 같은 순서로 이름을 찾아나가며, LEGB Rule이라고 부름
    1. `Local scope` : 지역 범위(현재 작업 중인 범위)
    2. `Enclosed scope` : 지역 범위 한 단계 위 범위
    3. `Global scope` : 최상단에 위치한 범위
    4. `Built-in scope` : 모든 것을 담고 있는 범위(정의하지 않고 사용할 수 있는 모든 것)
        1. ex) print()
- **함수 내에서는 바깥 Scope의 변수에 접근 가능하나 수정은 할 수 없음**

#### LEGB

##### Global 문

- 현재 코드 블록 전체에 적용되며, 나열된 식별자(이름)이 global variable임을 나타냄
    - global에 나열된 이름은 같은 코드 블록에서 global 앞에 등장할 수 없음
    - global에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함

##### nonlocal

- global을 제외하고 가장 가까운 (둘러싸고 있는) scope의 변수를 연결하도록 함
    - nonlocal에 나열된 이름은 같은 코드 블록에서 nonlocal 앞에 등장할 수 없음
    - nonlocal에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함
- global과는 달리 이미 존재하는 이름과의 연결만 가능함

#### **함수의 범위 주의**

- 기본적으로 함수에서 선언된 변수는 Local scope에 생성되며 ,함수 종료 시 사라짐
- 해당 scope에 변수가 없는 경우 LEGB rule에 의해 이름을 검색함
    - 변수에 접근은 가능하지만, 해당 변수를 수정할 수는 없음
    - 값을 할당하는 경우 해당 scope의 이름공간에 새롭게 생성되기 때문
    - **단, 함수 내에서 필요한 상위 scope 변수는 argument로 넘겨서 활용할 것**
- 상위 scope에 있는 변수를 수정하고 싶다면 global, nonlocal 키워드를 활용 가능
    - 단, 코드가 복잡해지면서 변수의 변경을 추적하기 어렵고, 예기치 못한 오류가 발생
    - 가급적 사용하지 않는 것을 권장하면, **함수로 값을 바꾸고자 한다면 항상 argument로 넘기고 리턴 값을 사용하는 것을 추천**

#### 내장 함수

- map(function, iterable)

- filter(function, iterable)

- zip(*iterables)

- lambda[parameter] : 표현식


- 재귀 함수(recursive function)
    - 자기 자신을 호출하는 함수
    - 무한한 호출을 목표로 하는 것이 아니며, 알고리즘 설계 및 구현에서 유용하게 활용 가능
        - 알고리즘 중 재귀 함수로 로직을 표현하기 쉬운 경우가 있음 (예: 점화식)
        - 변수의 사용이 줄어들며, 코드의 가독성이 높아짐
    - 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성


- 재귀 함수 주의 사항
    1. 재귀 함수는 `base case` 에 도달할 때까지 함수를 호출함
    2. 메모리 스택이 넘치게 되면(`stack overflow`) 프로그램이 동작하지 않게 됨
    3. 파이썬에서는 최대 재귀 깊이(`maximum recursion depth`)가 1000번으로, 호출 횟수가 이를 넘어가게 되면 `Recursion Error` 발생
- 재귀 함수를 반복문으로 표현


- 반복문과 재귀 함수 비교
    - 알고리즘 자체가 재귀적인 표현이 자연스러운 경우 재귀함수를 사용함
    - 재귀 호출은 변수 사용을 줄여줄 수 있음
    - 재귀 호출은 입력 값이 커질 수록 연산 속도가 오래 걸림

#### 모듈

##### 모듈과 패키지

- **모듈** : 다양한 기능을 하나의 파일로
- **패키지** : 다양한 파일을 하나의 폴더로
- **라이브러리** : 다양한 패키지를 하나의 묶음으로
- 라이브러리 vs 프레임워크 구분이 쉽지 않다
    - 라이브러리 → 도구 (삽) : 내가 주도적으로 할 수 있음
    - 프레임워크 → 도구 (포크레인) : 사실상 내가 막 다룰 수 없음
- **pip** : 이것을 관리하는 관리자
- **가상환경** : 패키지의 활용 공간

##### 모듈과 패키지

- 외부 개발자가 만든 코드를 가져다 쓸 수 있다
- 모듈
    - 특정 기능을 하는 코드를 파이썬 파일(,py) 단위로 작성한 거
- 패키지
    - 특정 기능과 관련된 여러 모듈의 집합
    - 패키지 안에는 또 다른 서브 패키지를 포함

##### 가상환경

- 파이썬 표준 라이브러리가 아닌 외부 패키지와 모듈을 사용하는 경우
- 모두 pip를 통해 설치를 해야함
- 복수의 프로젝트를 하는 경우 버전이 상이할 수 있음
    - 과거 외주 프로젝트 - django 버전 2.x
    - 신규 회사 프로젝트 - django 버전 3.x
- 이러한 경우 가상환경을 만들어 프로젝트 별로 독립적인 패키지를 관리 할 수 있음
- 가상 환경을 만들고 관리하는데 사용되는 모듈(Python 버전 3.5부터)
- 특정 디렉토리에 가상 환경을 만들고, 고유한 파이썬 패키지 집합을 가질 수 있음
    - 특정 폴더에 가상 환경이(패키지 집합 폴더 등) 있고
    - 실행환경(예-bash{)에서 가상환경을 활성화 시켜
    - 해당 폴더에 있는 패키지를 관리/사용함