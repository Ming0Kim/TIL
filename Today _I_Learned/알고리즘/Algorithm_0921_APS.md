# APS 응용 - 완전 검색 & 그리디

강의날짜: 2022/09/21
공부유형: 강의
복습: No
분야: 알고리즘
작성일시: 2022년 9월 21일 오전 11:35
태그: baby-jin, 반복과재귀, 부분집합, 순열, 완전검색기법, 조합, 탐욕알고리즘, 활동선택문제
편집일시: 2022년 9월 21일 오후 5:07

### 학습목표

- 재귀적 알고리즘의 특성을 이해하고 이를 구현하기 위한 재귀호출에 대해 학습한다
- 완전 검색의 개념을 이해하고 완전 검색을 통한 문제 해결 방법에 대해 학습한다
- 조합적 문제(Combinatorial Problems)에 대한 완전 검색 방법에 대해 이해한다
    - 순열, 조합, 부분집합을 생성하는 알고리즘을 학습한다
- 탐욕 알고리즘 기법의 개념과 주요 특성을 이해한다

## 반복(Iteration)과 재귀(Recursion)

---

- 반복과 재귀는 유사한 작업을 수행할 수 있다
- 반복은 수행하는 작업이 완료될 때까지 계속 반복
    - 루프(for, while 구조)
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
    - 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다
    - 재귀 함수로 구현

### 반복구조

- 초기화 : 반복되는 명령문을 실행하기 전에 (한번만) 조건 검사에 사용할 변수의 초기값 설정
- 조건검사 ( check control expression )
- 반복할 명령문 실행 (action)
- 업데이트(loop update)
    - 무한 루프(infinite loop)가 되지 않게 조건이 거짓(false)이 되게 한다
    
    ![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled.png)
    

### 반복을 이용한 선택정렬

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%201.png)

### 재귀적 알고리즘

- 재귀적 정의는 두 부분으로 나뉜다
- 하나 또는 그 이상의 기본 경우(basis case or rule)
    - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드(seed)역할
- 하나 또는 그 이상의 유도된 경우(inductive case or rule)
    - 새로운 집합의 원소를 생성하기 이ㅜ해 결합되어지는 방법

### 재귀 함수 (recursive function)

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현한다
- 따라서, 기본 부분(basis part)와 유도 부분(inductive part)로 구성된다
- 재귀적 프로그램을 작성하는 것은 반복 구조에 대해 간결하고 이해하기 쉽다
    - 그러나, 재귀에 대해 익숙하지 않은 개발자들은 재귀적 프로그램이 어렵다고 느낀다
- 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다 따라서 재귀 호출은 반복적인 스태긔 사용을 의미하며 메모리 및 속도에서 성능 저하가 발생한다

### 팩토리얼 재귀 함수

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%202.png)

### 팩토리얼 재귀함수의 호출

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%203.png)

### 반복 또는 재귀?

- 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스럽다
    - 추상 자료형 (list, tree 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많다
- 일반적으로, 재귀적 알고리즘은 반복(iterative) 알고리즘보다 더 많은 메모리와 연산을 필요로 한다
- **입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다**

### 반복과 재귀의 비교

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%204.png)

### 2^k 연산에 대한 재귀와 반복

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%205.png)

## 완전 검색 기법

---

### brute-force

- brute-force는 문제를 해결하기 위한 간단하고 쉬운 접근법이다
    - force의 의미는 사람(지능)보다는 컴퓨터의 force를 의미한다
- brute-force 방법은 대부분의 문제에 적용 가능하다
- 상대적으로 빠른 시간에 문제 해결(알고리즘 설계)을 할 수 있다
- 문제에 포함된 자료(요소, 인스턴스)의 크기가 작다면 유용하다
- 학술적 또는 교육적 목적을 위해 알고리즘의 효율성을 판단하기 위한 척도로 사용된다

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%206.png)

### 완전 검색

- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다
    - 완전검색은 입력의 크기를 작게 해서 간편하고 빠르게 답을 구하는 프로그램을 작성한다
- 이를 기반으로 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있다
- 검정 등에서 주어진 문제를 풀 때, **우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다**
- 완전검색을 통한 Baby-gin 접근

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%207.png)

- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것이다
- 또한, 이들은 전형적으로 순열(permutation), 조합(combination), 그리고 부분집합(subsets)과 같은 조합적 문제들(Combinatorial Problems)과 연관된다
- 완전 검색은 조합적 문제에 대한 brute-force 방법이다

## 순열

---

### 문제 제시 : 여행사 BIG sale!

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%208.png)

### 순열

- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%209.png)

- 다수의 알고리즘 문제들은 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련있다
    - 예) TSP(Traveling Salesman Problem)
- N개의 요소들에 대해서 n!개의 순열들이 존재한다
    - 12! = 479,001,600
    - n > 12인 경우, 시간 복잡도 폭발적으로 증가
    
    ![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2010.png)
    

### 단순하게 순열을 생성하는 방법

- {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
    - 동일한 숫자가 포함되지 않았을때, 각자리수 별로 loop을 이용해 아래와 같이 구현할 수 있다
    
    ![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2011.png)
    
    ```python
    for i in range(1, 4):
        for j in range(1, 4):
            if i != j:
                for k in range(1, 4):
                    if k != i and k != j:
                        print(i, j, k)
    ```
    

### 순열 생성 방법

- 사전적 순서(Lexicographic-Order)
    - {1, 2, 3}, n = 3인 경우 다음과 같이 생성된다
    - [1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]
- 최소 변경을 통한 방법(Minimum-exchange requirement)
    - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 교환을 통해 생성

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2012.png)

- 최소한의 변경(Minimum-change reauirement)을 통해 다음 순열을 생성하는 방법

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2013.png)

- 재귀 호출을 통한 순열 생성

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2014.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2015.png)

```python
def f(i, k):
    if i == k:    # 인덱스 i == 원소의 개수
        print(p)
    else:
        for j in range(i, k):
            p[i], p[j] = p[j], p[i]
            f(i+1, k)
            p[i], p[j] = p[j], p[i]

p = [1, 2, 3]
f(0, 3)

'''
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 2, 1]
[3, 1, 2]

Process finished with exit code 0

'''
```

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2016.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2017.png)

```python
def f(i, k):
    if i == k:
        print(p)
    else:
        for j in range(k):
            if used[j] == 0:     # a[j]가 아직 사용되지 않았으면
                used[j] = 1      # a[j]가 사용됨으로 표시
                p[i] = a[j]      # p[i]는 a[j]로 결정
                f(i+1, k)        # p[i+1] 값을 결정하러 이동
                used[j] = 0      # a[j]를 다른 자리에서 쓸 수 있도록 해제

N = 3
a = [i for i in range(1, N+1)]
used = [0] * N
p = [0] * N
f(0, N)

'''
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]

Process finished with exit code 0

'''
```

```python
# N개 중에 R개 고르기

def f(i, k, r):
    if i == r:
        print(p)
    else:
        for j in range(k):
            if used[j] == 0:     # a[j]가 아직 사용되지 않았으면
                used[j] = 1      # a[j]가 사용됨으로 표시
                p[i] = a[j]      # p[i]는 a[j]로 결정
                f(i+1, k, r)        # p[i+1] 값을 결정하러 이동
                used[j] = 0      # a[j]를 다른 자리에서 쓸 수 있도록 해제

N = 5
R = 2
a = [i for i in range(1, N+1)]
used = [0] * N
p = [0] * R
f(0, N, R)

'''
[1, 2]
[1, 3]
[1, 4]
[1, 5]
[2, 1]
[2, 3]
[2, 4]
[2, 5]
[3, 1]
[3, 2]
[3, 4]
[3, 5]
[4, 1]
[4, 2]
[4, 3]
[4, 5]
[5, 1]
[5, 2]
[5, 3]
[5, 4]

Process finished with exit code 0

'''
```

```python
# baby-jin game

def f(i, k, r):
    if i == r:
        print(p)
    else:
        for j in range(k):
            if used[j] == 0:     # a[j]가 아직 사용되지 않았으면
                used[j] = 1      # a[j]가 사용됨으로 표시
                p[i] = a[j]      # p[i]는 a[j]로 결정
                f(i+1, k, r)        # p[i+1] 값을 결정하러 이동
                used[j] = 0      # a[j]를 다른 자리에서 쓸 수 있도록 해제

N = 6
R = 6
a = [1, 2, 4, 7, 8, 3]
used = [0] * N
p = [0] * R
f(0, N, R)
```

```python
def f(i, k):
    global minV
    if i == k:  # 인덱스 i == 원소의 개수
        s = 0   # 모든 L행에서 p[L]열을 골랐을 때의 최소값
        for l in range(k):
            s += arr[l][p[l]]
        if minV > s:
            minV = s
        print(p)
    else:
        for j in range(i, k):
            p[i], p[j] = p[j], p[i]
            f(i+1, k)
            p[i], p[j] = p[j], p[i]

t = int(input())
for tc in range(1, t+1):
    n = int(input())
    arr = [list(map(int, input().split())) for _ in range(n)]
    p = [ i for i in range(n)]
    minV = n*10
    f(0, n)
print(f'#{tc} {minV}')
```

## 부분집합

---

- 집합에 포함된 원소들을 선택하는 것이다
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분집합을 찾는 것이다
    - 배낭 짐싸기(knapsack)
- N개의 원소를 포함한 집합
    - 자기 자신과 공집합 포함한 모든 부분집합(power set)의 개수는 2^n개
    - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

### 단순하게 모든 부분집합 생성하는 방법

- 4개 원소를 포함한 집합에 대한 power set 구하기

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2018.png)

### 바이너리 카운팅을 통한 사전적 순서(Lexicographic Order)

- 부분집합을 생성하기 위한 가장 자연스러운 방법이다
- 바이너리 카운팅(Binary Counting)은 사전적 순서로 생성하기 위한 가장 간단한 방법이다

### 바이너리 카운팅(Binary Counting)

- 원소 수에 해당하는 N개의 비트열을 이용한다
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2019.png)

- 바이너리 카운팅을 통한 부분집합 생성 코드 예

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2020.png)

```python
def f(i, k):
    if i == k:
        # print(bit)
        for j in range(k):
            if bit[j]:
                print(arr[j], end=' ')
        print()
    else:
        bit[i] = 0
        f(i+1, k)
        bit[i] = 1
        f(i+1, k)

arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

bit = [0] * n   # bit[i] arr[i]가 부분집합의 원소인지 표시
f(0, n)

'''
4 
5 
5 4 
1 
1 4 
1 5 
1 5 4 
7 
7 4 
7 5 
7 5 4 
7 1 
7 1 4 
7 1 5 
7 1 5 4 
6 
6 4 
6 5 
6 5 4 
6 1 
6 1 4 
6 1 5 
6 1 5 4 
6 7 
6 7 4 
6 7 5 
6 7 5 4 
6 7 1 
6 7 1 4 
6 7 1 5 
6 7 1 5 4 
3 
3 4 
3 5 
3 5 4 
3 1 
3 1 4 
3 1 5 
3 1 5 4 
3 7 
3 7 4 
3 7 5 
3 7 5 4 
3 7 1 
3 7 1 4 
3 7 1 5 
3 7 1 5 4 
3 6 
3 6 4 
3 6 5 
3 6 5 4 
3 6 1 
3 6 1 4 
3 6 1 5 
3 6 1 5 4 
3 6 7 
3 6 7 4 
3 6 7 5 
3 6 7 5 4 
3 6 7 1 
3 6 7 1 4 
3 6 7 1 5 
3 6 7 1 5 4 

Process finished with exit code 0

'''
```

```python
# 비트 이용
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)
for i in range(1<<n):
    for j in range(n):
        if i & (1<<j):    # j 번 비트가 0이 아니면 arr[j] 부분집합의 원소
            print(arr[j], end=' ')
    print()

'''
3 
6 
3 6 
7 
3 7 
6 7 
3 6 7 
1 
3 1 
6 1 
3 6 1 
7 1 
3 7 1 
6 7 1 
3 6 7 1 
5 
3 5 
6 5 
3 6 5 
7 5 
3 7 5 
6 7 5 
3 6 7 5 
1 5 
3 1 5 
6 1 5 
3 6 1 5 
7 1 5 
3 7 1 5 
6 7 1 5 
3 6 7 1 5 
4 
3 4 
6 4 
3 6 4 
7 4 
3 7 4 
6 7 4 
3 6 7 4 
1 4 
3 1 4 
6 1 4 
3 6 1 4 
7 1 4 
3 7 1 4 
6 7 1 4 
3 6 7 1 4 
5 4 
3 5 4 
6 5 4 
3 6 5 4 
7 5 4 
3 7 5 4 
6 7 5 4 
3 6 7 5 4 
1 5 4 
3 1 5 4 
6 1 5 4 
3 6 1 5 4 
7 1 5 4 
3 7 1 5 4 
6 7 1 5 4 
3 6 7 1 5 4 

Process finished with exit code 0
'''
```

## 조합

---

- 서로 다른 n개의 원소 중 r개를 순서없이 골라낸 것을 조합(combination)이라고 부른다
- 조합의 수식

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2021.png)

### 재귀 호출을 이용한 조합 생성 알고리즘

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2022.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2023.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2024.png)

```python
N = 5
for i in range(N-2):
    for j in range(i+1, N-1):
        for k in range(j+1, N):
            print(i, j, k)
'''
0 1 2
0 1 3
0 1 4
0 2 3
0 2 4
0 3 4
1 2 3
1 2 4
1 3 4
2 3 4

Process finished with exit code 0
'''
```

### n개에서 r개를 고르는 조합(재귀)

```python
def nCr(n, r, s):
    if r == 0:
        print(*comb)
    else:
        for i in range(s, n-r+1):
            comb[r-1] = A[i]
            nCr(n, r-1, i+1)

A = [1, 2, 3, 4, 5]
n = len(A)
r = 3
comb = [0]*r
nCr(n, r, 0)

'''
3 2 1
4 2 1
5 2 1
4 3 1
5 3 1
5 4 1
4 3 2
5 3 2
5 4 2
5 4 3

Process finished with exit code 0

'''
```

## 탐욕 알고리즘

---

### 문제 제시: 거스름돈 줄이기

- 손님이 지불한 금액에서 물건값을 제한 차액(거스름돈)을 지불하는 문제를 생각해보자
- 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까

### 그리디 알고리즘

- 탐욕 알고리즘은 최적해를 구하는데 사용되는 근시안적인 방법
- 일반적으로, 머리속에 떠오르는 생각을 검증없이 바로 구현하면 Greedy 접근이 된다
- 여러 경우 중 하나를 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, **그것이 최적이라는 보장은 없다**
- 일단 한번 선택된 것은 번복하지 않는다. 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 또한 제한적인 문제들에 적용된다
- 최적화 문제(optimization)ㄹㄴ 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다

### 탐욕 알고리즘의 동작 과정

1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에  추가한다
2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행가능한지를 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다
3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다

### 탐욕 기법을 적용한 거스름돈 줄이기

1. 해 선택 : 여기에서는 멀리 내다볼 것 없이 가장 좋은 해를 선택한다. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어들므로 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가한다
2. 실행 가능성 검사 : 거스름돈이 손님에게 내드려야할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가서 현재보다 한 단꼐 작은 단위의 동전을 추가한다
3. 해 검사 : 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내드령 하는 액수와 일치하는 셈이다. 더 드려도, 덜 드려도 안되기 때문에 거스름돈을 확인해서 액수에 모자라면 다시 1로 돌아가서 거스름돈에 추가할 동전을 고른다
4. **최적해를 반드시 구한다는 보장은 없다**

### 배낭 짐싸기(KNapsack)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2025.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2026.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2027.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2028.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2029.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2030.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2031.png)

### 회의실 배정하기

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2032.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2033.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2034.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2035.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2036.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2037.png)

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2038.png)

### 탐욕 알고리즘의 필수 요소

- 탐욕적 선택 속성(greedy choice property)
    - 탐욕적 선택은 최적해로 갈 수 있음을 보여라
    - → 즉 탐욕적 선택은 항상 안전하다
- 최적 부분 구조(optimal substructure property)
    - 최적화 문제를 정형화하라
    - → 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다
- **[원문제의 최적해 + 탐욕적 선택 + 하위문제의 최적해]**임을 증명하라

### 탐욕 기법과 동적 계획법의 비교

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2039.png)

### 대표적인 탐욕 기법의 알고리즘들

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%20-%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%AB%20%E1%84%80%E1%85%A5%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%20&%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%B5%E1%84%83%E1%85%B5%206c77f6e693de47809ee519043aeeac23/Untitled%2040.png)

## Baby-gin 문제 해결

---

- 탐욕 기법을 통한 baby-gin 문제 해결
- 완전검색 아닌 방법으로 풀어보기

```python
'''
5
123123
124467
333444
444456
123444
'''

def f(i, k):
    global ans
    if i ==k:
        run = 0
        tri = 0
        if card[0]==card[1] and card[1] == card[2]:
            tri += 1
        if card[0]+1 == card[1] and card[1]+1 == card[2]:
            run += 1
        if card[3]==card[4] and card[4] == card[5]:
            tri += 1
        if card[3]+1==card[4] and card[4]+1 == card[5]:
            run += 1
        if tri + run == 2:
            ans = 'Baby Gin'
    else:
        for j in range(i, k):
            card[i], card[j] = card[j], card[i]
            f(i+1, k)
            card[i], card[j] = card[j], card[i]

t = int(input())
for tc in range(1, t+1):
    card = list(map(int, input()))
    ans = 'Lose'
    f(0, 6)
    print(f'#{tc} {ans}')
'''
#1 Baby Gin
#2 Lose
#3 Baby Gin
#4 Baby Gin

#5 Baby Gin

Process finished with exit code 0

'''
```

```python
'''
5
123123
124467
333444
444456
123444
'''

def f(i, k):
    if i ==k:
        run = 0
        tri = 0
        if card[0]==card[1] and card[1] == card[2]:
            tri += 1
        if card[0]+1 == card[1] and card[1]+1 == card[2]:
            run += 1
        if card[3]==card[4] and card[4] == card[5]:
            tri += 1
        if card[3]+1==card[4] and card[4]+1 == card[5]:
            run += 1
        if tri + run == 2:
            return 1
        else:
            return 0
    else:
        for j in range(i, k):
            card[i], card[j] = card[j], card[i]
            if f(i+1, k):
                return 1
            card[i], card[j] = card[j], card[i]
        return 0
t = int(input())
for tc in range(1, t+1):
    card = list(map(int, input()))
    ans = f(0,6)
    if ans:
        print(f'#{tc} Baby Gin')
    else:
        print(f'#{tc} Lose')
'''
#1 Baby Gin
#2 Lose
#3 Baby Gin
#4 Baby Gin

#5 Baby Gin

Process finished with exit code 0

'''
```

```python
'''
5
123123
124467
333444
444456
123444
'''
t = int(input())
for tc in range(1, t+1):
    card = int(input())
    c = [0] * 12

    i = 0
    while i < 6:
        c[card%10] += 1
        card //= 10
        i += 1
    tri = 0
    run = 0
    i = 0
    while i < 10:
        if c[i] >= 3:
            c[i] -= 3
            tri += 1
            continue
        if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
            c[i] -= 1
            c[i+1] -= 1
            c[i+2] -= 1
            run += 1
            continue
        i += 1
    if run + tri == 2:
        print(f'#{tc} Baby Gin')
    else:
        print(f'#{tc} Lose')
'''
#1 Baby Gin
#2 Lose
#3 Baby Gin
#4 Baby Gin

#5 Baby Gin

Process finished with exit code 0

'''
```

## 연습

---

```python
# N개 중에 R개 고르기 - 맨 앞 1 고정

def f(i, k, r):
    if i == r:
        print(p)
    else:
        for j in range(k):
            if used[j] == 0:     # a[j]가 아직 사용되지 않았으면
                used[j] = 1      # a[j]가 사용됨으로 표시
                p[i] = a[j]      # p[i]는 a[j]로 결정
                f(i+1, k, r)        # p[i+1] 값을 결정하러 이동
                used[j] = 0      # a[j]를 다른 자리에서 쓸 수 있도록 해제

N = 5
R = 5
a = [i for i in range(1, N+1)]
used = [0] * N
p = [0] * R
p[0] = 1     # 맨 앞 1 고정
used[0] = 1  # 맨 앞 1 고정
f(1, N, R)   # 0번은 이미 1이니까 그 다음부터 찾아줘

'''
[1, 2, 3, 4, 5]
[1, 2, 3, 5, 4]
[1, 2, 4, 3, 5]
[1, 2, 4, 5, 3]
[1, 2, 5, 3, 4]
[1, 2, 5, 4, 3]
[1, 3, 2, 4, 5]
[1, 3, 2, 5, 4]
[1, 3, 4, 2, 5]
[1, 3, 4, 5, 2]
[1, 3, 5, 2, 4]
[1, 3, 5, 4, 2]
[1, 4, 2, 3, 5]
[1, 4, 2, 5, 3]
[1, 4, 3, 2, 5]
[1, 4, 3, 5, 2]
[1, 4, 5, 2, 3]
[1, 4, 5, 3, 2]
[1, 5, 2, 3, 4]
[1, 5, 2, 4, 3]
[1, 5, 3, 2, 4]
[1, 5, 3, 4, 2]
[1, 5, 4, 2, 3]
[1, 5, 4, 3, 2]

Process finished with exit code 0
'''
```

```python
# N개 중에 R개 고르기 - 앞에 2 고정

def f(i, k, r):
    if i == r:
        print(p)
    else:
        for j in range(k):
            if used[j] == 0:     # a[j]가 아직 사용되지 않았으면
                used[j] = 1      # a[j]가 사용됨으로 표시
                p[i] = a[j]      # p[i]는 a[j]로 결정
                f(i+1, k, r)        # p[i+1] 값을 결정하러 이동
                used[j] = 0      # a[j]를 다른 자리에서 쓸 수 있도록 해제

N = 5
R = 5
a = [i for i in range(1, N+1)]
used = [0] * N
p = [0] * R
p[0] = 2    # 2 고정
used[1] = 1
f(1, N, R)

'''
[2, 1, 3, 4, 5]
[2, 1, 3, 5, 4]
[2, 1, 4, 3, 5]
[2, 1, 4, 5, 3]
[2, 1, 5, 3, 4]
[2, 1, 5, 4, 3]
[2, 3, 1, 4, 5]
[2, 3, 1, 5, 4]
[2, 3, 4, 1, 5]
[2, 3, 4, 5, 1]
[2, 3, 5, 1, 4]
[2, 3, 5, 4, 1]
[2, 4, 1, 3, 5]
[2, 4, 1, 5, 3]
[2, 4, 3, 1, 5]
[2, 4, 3, 5, 1]
[2, 4, 5, 1, 3]
[2, 4, 5, 3, 1]
[2, 5, 1, 3, 4]
[2, 5, 1, 4, 3]
[2, 5, 3, 1, 4]
[2, 5, 3, 4, 1]
[2, 5, 4, 1, 3]
[2, 5, 4, 3, 1]

Process finished with exit code 0
'''
```

```python
def f(i, k, s):
    global minV
    if i == k:  # 인덱스 i == 원소의 개수
        if minV > s:
            minV = s
    # elif s >= minV:
    #     return
    else:
        for j in range(i, k):
            p[i], p[j] = p[j], p[i]
            f(i+1, k, s+ arr[i][p[i]])
            p[i], p[j] = p[j], p[i]

t = int(input())
for tc in range(1, t+1):
    n = int(input())
    arr = [list(map(int, input().split())) for _ in range(n)]
    p = [i for i in range(n)]
    minV = n*10
    f(0, n, s)
    print(f'#{tc} {minV}')
```