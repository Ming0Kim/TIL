# APS 응용

강의날짜: 2022/09/19
공부유형: 강의
복습: No
분야: 알고리즘
작성일시: 2022년 9월 19일 오전 10:49
편집일시: 2022년 9월 19일 오후 3:21

## SW 문제해결

---

### 학습목표

1. SW 문제 해결 역량이란 무엇인가를 이해하고 역량을 강화하는 방법을 이해한다
2. 효율적인 알고리즘의 필요성을 이해하고 알고리즘의 성능 측정 방법 중 하나인 시간복잡도에 대해 이해한다
3. 프로그램을 작성하기 위한 기본 중 표준 입출력 방법에 대해 이해한다
4. 비트 수준의 연산과 알고리즘에 대해 이해한다
5. 컴퓨터에서의 실수 표현 방법에 대해 이해한다

### 문재 해결 과정

1. 문제를 읽고 이해한다
2. 문제를 익숙한 용어로 재정의한다
3. 어떻게 해결할지 계획을 세운다
4. 계획을 검증한다
5. 프로그램으로 구현한다
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

### 문제 해결 전략

- 직관과 체계적인 접근

### 체계적인 접근을 위한 질문들

1. 비슷한 문제를 풀어본 적이 있던가
2. 단순한 방법에서 시작할 수 있을까
3. 문제를 단순화할 수 있을까
4. 그림으로 그려볼 수 있을까
5. 수식으로 표현할 수 있을까
6. 문제를 분해할 수 있을까
7. 뒤에서부터 생각해서 문제를 풀 수 있을까
8. 특정 형태의 답만을 고려할 수 있을까

## 복잡도 분석

---

### 복잡도의 점근적 표기

- 시간복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러개의 항을 가지는 다항식이다.
- 이를 단순한 함수로 표현하기 위해 점근적 표기 (`Asymptotic Notation`)을 사용한다
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다
    - `Big-Oh`표기 , `Big-Omega`표기, `Big-Theta`표기

### O(Big-Oh) 표기

- O-표기는 복잡도의 점근적 상한을 나타낸다
- 복잡도가 f(n) = 2n^2-7n+4이라면 f(n)의 O-표기는 O(n^2)이다
- **단순히 실행시간이 n^2에 비례하는 알고리즘이라고 말함**

### Big-Omega 표기

- 복잡도의 점근적 하한을 의미한다
- **최소한 이만한 시간은 걸린다**

### Big-Theta 표기

- **f(n)은 n이 증가함에 따라 n^2과 동일한 증가율을 가진다라는 의미이다**

### 자주 사용하는 O-표기

- `O(1)` : 상수시간
- `O(logn)` : 로그(대수)시간
- `O(n)` : 선형 시간
- `O(nlogn)` : 로그 선형 시간
- `O(n^2)` : 제곱 시간
- `O(n^3)` : 세제곱 시간
- `O(2^n)` : 지수 시간

## 표준 입출력 방법

---

### 입력

- Raw 값의 입력 : `input()`
    - 받은 입력값을 문자열로 취급
- Evaulated된 값 입력 : `eval(input())`
    - 받은 입력값을 평가된 데이터형으로 취급

### 출력

- `print()`
    - 표준 출력 함수. 출력값의 마지막에 개행 문자 포함
- `print('text', end='')`
    - 출력시 마지막에 개행문자 제외할 시
- `print('%d'%number)`
    - Formatting된 출력

### 파일의 내용을 표준 입력으로 읽어오는 방법

- `import sys`
- `sys.stdin = open('a.txt', 'r')`

```python
import sys
sys.stdin = open('input.txt', 'r')
sys.stdout = open('output.txt', 'w')

text = input()
print(text)
```

### Python3 소스코드

```python
import sys
sys.stdin = open('input.txt', 'r')

T = int(input())
r, c = map(int, input().split())

field = []
for i in range(0, r):
	row = input()
	field.append(row)

print(T)
print(str(r) + ' ' + str(c))
for i in rnage(0, r):
	print(field[i])
```

## 비트 연산

---

### 비트 연산자

- `&` : 비트 단위로 AND 연산을 한다
- `\` : 비트단위로 OR 연산을 한다
- `^` : 비트단위로 XOR 연산을 한다. ( 같으면 0 다르면 1)
- `~` : 단항 연산자로서 피연산자의 모든 비트를 반전시킨다
- `<<` : 피연산자의 비트 열을 왼쪽으로 이동시킨다 ( num << 2 )
- `>>` : 피연산자의 비트 열을 오른쪽으로 이동시킨다 ( num >> 2 )

### 1 << n

- 2^n의 값을 갖는다
- 원소가 n개일 경우의 모든 부분집합의 수를 의미한다
- Pwer set ( 모든 부분 집합)
    - 공집합과 자기 자신을 포함한 모든 부분집합
    - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다

### i & ( 1 << j)

- 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다
- **i의 j번 비트 검사**

### 비트 연산 예제

```python
def Bbit_print(i):
	output = ''
	for j in range(7, -1, -1):
		output += 'i' if i & (1 << j) else '0'
	print(output)

for i in range(-5, 6):
	print('%3d = '%i, end='')
	Bbit_print(i)
```

### 비트 연산 예제 2

```python
def Bbit_print(i):
	output = ''
	for j in range(7, -1, -1):
		output += '1' if i & (1<<j) else '0'
	print(output, end=' ')
a = 0x10
x = 0x01020304
print('%d = '%x, end='')
Bbit_print(a)
print()
print('0%x = '% x, end='')
for i in rangE(0, 4):
	Bbit_print((x>>i*8) & 0xff)
```

### 엔디안(Endianness)

- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다르다
- 주의 : 속도 향상을 위해 바이트 단위와 워드 다누이를 변환하여 연산할때 올바로 이해하지 않으면 오류를 발생시킬 수 있다
- `빅 엔디안(Big-endian)` : 보통 큰 단위가 앞에 나옴 네트워크
- `리틀 엔디안(Little-endian)` : 작은 단위가 앞에 나옴 대다수 데스크탑 컴퓨터

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%204dc8c74d425743d6b389254b87a8b56f/Untitled.png)

- 엔디안 확인 코드

```python
import sys
print(sys.byteorder)
```

### 비트 연산 예제3

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%204dc8c74d425743d6b389254b87a8b56f/Untitled%201.png)

### 비트 연산 예제4

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%204dc8c74d425743d6b389254b87a8b56f/Untitled%202.png)

### 비트 연산 예제5

- 비트 연산자 ^를 두 번 연산하면 처음 값을 반환한다

![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%204dc8c74d425743d6b389254b87a8b56f/Untitled%203.png)

## 진수

---

- 2진수, 8딘수, 10진수, 16진수
- 10진수 ⇒ 타 진수로 변환
    - 원하는 타진법의 수로 나누뒤 나머지를 거꾸로 읽는다
    - 149(10) = 10010101(2) = 225(8) = 95(16)
- 타 진수 ⇒ 10진수로 변환
    - 135(8) = 1*8^2 + 3*8^1 + 5*8^0 = 93(10)
    
    ![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%204dc8c74d425743d6b389254b87a8b56f/Untitled%204.png)
    
    ![Untitled](APS%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%204dc8c74d425743d6b389254b87a8b56f/Untitled%205.png)
    

### 컴퓨터에서의 음의 정수 표현 방법

- 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0로 변환한다
- -6 : 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 : 부호와 절대값 표현
- -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 : 1의 보수 표현
- 2의 보수 : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다
- -6 : 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 : 2의 보수 표현